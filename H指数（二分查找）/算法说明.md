# H指数

### 题目：

给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数，citations 已经按照 升序排列 。计算并返回该研究者的 h 指数。

h 指数的定义：h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （n 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。

请你设计并实现对数时间复杂度的算法解决此问题。

#### 示例：

输入：citations = [0,1,3,5,6]

输出：3

解释：给定数组表示研究者共有5篇论文，每篇论文被引用了0，1，3，5，6次。由于研究者有3篇论文每篇**至少**被引用了3次，其余两篇论文每篇被引用**不多于**3次，所以他的h指数为3.





### 算法思路：

示例分析：

h=0，含义为[至少发表了0篇，且这0篇论文至少被引用0次]，空集满足，成立

h=1，含义为[至少发表了1篇，且这1篇论文至少被引用1次]，可以找到这样的组合如[1]，成立

h=2，含义为[至少发表了2篇，且这2篇论文至少被引用2次]，可以找到这样的组合如[3，5]，成立

h=3，含义为[至少发表了3篇，且这3篇论文至少被引用3次]，可以找到这样的组合如[3，5，6]，成立

h=4，含义为[至少发表了4篇，且这4篇论文至少被引用4次]，找不到这样的组合，不成立

...

使用二分答案，对于任意的cs，都必然对应一个最大的h值，且小于等于该h的情况均满足，大于h的均不满足。

在以最大h值为分割点的数轴上具有二段性。

时间复杂度：对[0,n]做二分，复杂度为O(logn)，check对数组线性遍历，复杂度O(n)。整体复杂度O(nlogn)

空间复杂度O(1)



### 二分查找向下取整模板

```c++
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    return l;
}
```

### 二分查找向上取整模板

```c++
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```



## 解法2：

对于有序数组：

根据对 h 定义，若 cs升序，我们可推导出：

在最大的符合条件的分割点 x的右边（包含分割点），必然满足 cs[i]>=x
在最大的符合条件的分割点 x的左边，必然不满足 cs[i]>=x
因此，我们可以利用 分割点右边数的个数与分割点 cs[x]的大小关系进行二分 。

假设存在真实分割点下标 x，其值大小为 cs[x]，分割点右边的数值个数为 n−x，根据 H 指数 的定义，必然有 cs[x]>=n−x关系：

在分割点 x 的右边：cs[i] 非严格单调递增，数的个数严格单调递减，仍然满足 cs[i]>=n−i关系；
在分割点 x 的左边：cs[i]非严格单调递减，数的个数严格单调递增，x 作为真实分割点，必然不满足 cs[i]>=n−i关系。

```c++
class Solution {
public:
    int hIndex(vector<int>& citations) {
        int n = citations.size();
        int left = 0, right = n - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (citations[mid] >= n - mid) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return n - left;
    }
};
```

时间复杂度O(logn)

空间复杂度O(1)


